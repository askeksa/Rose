/* This file was generated by SableCC (http://www.sablecc.org/). */

#ifndef __rose__list_hh__
#define __rose__list_hh__

#include <vector>
#include <list>
#include <string>

namespace rose {

class Analysis;

class _List_helper {
  typedef std::list<Node> list_t;

  static void insert (_GenericNode *owner, list_t& guts, list_t::iterator pos, Node node);
  static list_t::iterator erase (_GenericNode *owner, list_t& guts, list_t::iterator begin, list_t::iterator end);
  static bool erase (_GenericNode *owner, list_t& guts, Node node);
  static bool replace (_GenericNode *owner, list_t& guts, Node node, Node new_node);
  static void assign (_GenericNode *owner, list_t& guts, const _GenericNode *fowner, const list_t& from);
  static void apply (list_t& guts, Analysis& analysis);
  static void reverse_apply (list_t& guts, Analysis& analysis);

  template <typename U> friend class List;
  friend class _GenericNode;
};

template<typename T>
class List
{
  typedef typename _List_helper::list_t list_t;

public:
  class iterator {
    iterator(list_t::iterator it) : it(it) { }
    list_t::iterator it;
    friend class List<T>;

  public:
    inline T* operator->() { return (T *)it.operator->(); }
    inline T operator* () { return reinterpret_cast<T&>(*it); }

    inline iterator operator++ (int) { iterator rit = *this; it++; return rit; }
    inline iterator operator-- (int) { iterator rit = *this; it--; return rit;}
    inline iterator& operator++ () { ++it; return *this; }
    inline iterator& operator-- () { --it; return *this;}

    friend inline bool operator== (const iterator& l, const iterator& r) { return l.it == r.it; }
    friend inline bool operator!= (const iterator& l, const iterator& r) { return l.it != r.it; }
  };

  inline List () : owner(0) { }
  inline List (const List<T>& l) : owner (0) { _List_helper::assign (owner, list, l.owner, l.list); }
  inline ~List () { }

  inline List<T>& operator= (const List<T>& l) { _List_helper::assign (owner, list, l.owner, l.list); return *this; }

  inline iterator begin() { return list.begin(); }
  inline iterator end() { return list.end(); }

  inline void push_back (T node) { insert (end(), node); }
  inline void push_front (T node) { insert (begin(), node); }

  inline T front () { return reinterpret_cast<T&>(list.front()); }
  inline T back () { return reinterpret_cast<T&>(list.back()); }

  inline void insert (iterator pos, T node) { _List_helper::insert (owner, list, pos.it, node); }

  inline iterator erase (iterator first, iterator last) { return _List_helper::erase (owner, list, first.it, last.it); }

  inline iterator erase (iterator pos)
  { iterator n = pos; ++n; return erase(pos, n); }

  inline bool erase (T node) { return _List_helper::erase (owner, list, node); }
  inline bool replace (T old_node, T new_node) { return _List_helper::replace(owner, list, old_node, new_node); }

  inline void clear () { _List_helper::erase(owner, list, list.begin(), list.end()); }

  inline bool empty () const { return list.empty(); }
  inline size_t size () const { return list.size(); }

  inline void apply (Analysis& analysis) { _List_helper::apply (list, analysis); }
  inline void reverse_apply (Analysis& analysis) { _List_helper::reverse_apply (list, analysis); }

private:
  _GenericNode *owner;
  list_t list;

  inline void setOwner (_GenericNode *o) { owner = o; }

  friend class _GenericNode;
  friend class Node;
};

} // namespace rose {

#endif // !__rose__list_hh__
