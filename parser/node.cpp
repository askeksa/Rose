/* This file was generated by SableCC (http://www.sablecc.org/). */

#include "node.h"
#include "list.h"
#include "token.h"

struct rose::_NodeData {
  List<Node> list;
  Node node;
};

rose::Exception::~Exception ()
{
}

rose::_GenericNode::_GenericNode ()
{
}

rose::_GenericNode::~_GenericNode ()
{
  for ( size_t i = 0; i < nodes.size(); i++ ) {
      if ( type_info->prod_elem_is_list[i] )
          nodes[i].list.clear();
      else
          if ( nodes[i].node ) nodes[i].node.parent(0);
  }
}

rose::_GenericNode *rose::_GenericNode::initToken (const _TypeInfo *type_info,
    int line, int pos, const std::string& text)
{
  _GenericNode *node = new _GenericNode();
  node->ref_count = 0;
  node->parent = 0;
  node->type_info = type_info;
  node->line = line;
  node->pos = pos;
  node->text = text;
  return node;
}

rose::_GenericNode *rose::_GenericNode::initProd (const _TypeInfo *type_info, void **args)
{
  _GenericNode *node = new _GenericNode();
  node->ref_count = 0;
  node->parent = 0;
  node->type_info = type_info;
  node->nodes.resize (type_info->prod_elem_count);

  for ( size_t i = 0; i < node->nodes.size(); i++ ) {
      if ( type_info->prod_elem_is_list[i] )
          node->nodes[i].list.setOwner(node);
  }

  if ( args ) {
      for ( size_t i = 0; i < node->nodes.size(); i++ ) {
          if ( type_info->prod_elem_is_list[i] )
              _List_helper::assign (node, node->nodes[i].list.list, 0, *((_List_helper::list_t*)args[i]));
          else
              node->setChildNode ((int) i, *((Node *)args[i]));
      }
  }

  return node;
}

rose::Node rose::_GenericNode::clone () const
{
  _GenericNode *node = new _GenericNode ();
  node->type_info = type_info;
  node->ref_count = 0;
  node->parent = 0;

  node->text = text;
  node->line = line;
  node->pos = pos;

  node->nodes.resize (type_info->prod_elem_count);
  for ( size_t i = 0; i < node->nodes.size(); i++ ) {
      if ( type_info->prod_elem_is_list[i] ) {
          node->nodes[i].list.setOwner(node);
          for ( std::list<Node>::const_iterator it = nodes[i].list.list.begin(); it != nodes[i].list.list.end(); it++ ) {
              node->nodes[i].list.push_back (it->clone());
          }
      } else {
          node->nodes[i].node = nodes[i].node.clone();
      }
  }
  return node;
}


std::string rose::_GenericNode::toString () const
{
  if ( type_info->type == _TypeInfo::is_token ) return text + " ";

  std::string ret;

  for ( size_t i = 0; i < nodes.size(); i++ ) {
      if ( type_info->prod_elem_is_list[i] ) {
          for ( std::list<Node>::const_iterator it = nodes[i].list.list.begin(); it != nodes[i].list.list.end(); it++ ) {
              ret += (*it).toString();
          }
      } else {
          if ( nodes[i].node ) ret += nodes[i].node.toString();
      }
  }

  return ret;
}

rose::Node rose::_GenericNode::getChildNode (int id)
{
  return nodes[id].node;
}

rose::List<rose::Node>& rose::_GenericNode::getChildList (int id)
{
  return nodes[id].list;
}

void rose::_GenericNode::setChildNode (int id, Node node)
{
  Node &var = nodes[id].node;
  if ( var ) var.parent(0);
  if ( node ) {
      if ( node.parent() )
          node.parent().removeChild (node);
      node.parent (this);
  }
  var = node;
}

void rose::_GenericNode::removeChild (Node node)
{
  if ( !node )
      throw (Exception ("_GenericNode::removeChild: null given, invalid condition, this should not happen!"));

  for ( size_t i = 0; i < nodes.size(); i++ ) {
      if ( type_info->prod_elem_is_list[i] ) {
          if ( nodes[i].list.erase(node) ) return;
      } else {
          if ( nodes[i].node == node ) {
              nodes[i].node = Node();
              return;
          }
      }
  }
}

void rose::_GenericNode::replaceChild (Node old_child, Node new_child)
{
  if ( !old_child )
      throw (Exception ("_GenericNode::replaceChild: null given, invalid condition, this should not happen!"));

  for ( size_t i = 0; i < nodes.size(); i++ ) {
      if ( type_info->prod_elem_is_list[i] ) {
          if ( nodes[i].list.replace (old_child, new_child) ) return;
      } else {
          if ( nodes[i].node == old_child ) {
              setChildNode ((int) i, new_child);
              return;
          }
      }
  }
}

void rose::_GenericNode::replaceBy (Node node)
{
  if ( !parent || node.obj == this ) return;   // no point with no parent and no can do replacing by ourselves

  if ( !node ) {
      parent->removeChild (this);
  } else {
      // now we have to do complicated type checks

      // 1) if we are token then node must be token and our types must match
      if ( type_info->is(&Token::type_info) ) {
          if ( type_info->type_id != node.type_id() )
              throw Exception (std::string("replaceBy: trying to replace a token of different type, must be '") +
                  type_info->name + "', '" + node.type_name() + "' given");
      } else {
      // 2) Expected prod but we got token
          if ( node.is<Token>() )
              throw Exception (std::string("replaceBy: trying to replace a production with token, must be '") +
                  type_info->parent->name + "', '" + node.type_name() + "' given");

      // 3) now we can assume we have productions here, node must share the parent type of this type
          if ( node.obj->type_info->parent->type_id != type_info->parent->type_id )
              throw Exception (std::string("replaceBy: in this context given node must be of type '") +
                  type_info->parent->name + "', '" + node.obj->type_info->parent->name + "' given");
      }
      parent->replaceChild (this, node);
  }
}
