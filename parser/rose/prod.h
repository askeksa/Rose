/* This file was generated by SableCC (http://www.sablecc.org/). */

#ifndef __rose__prod_hh__
#define __rose__prod_hh__

namespace rose {

template <class T> class List;

class PProgram : public Node {
public:
  inline PProgram () : Node () { }

  static const _TypeInfo type_info;

  inline PProgram clone () const { return Node::clone().unsafe_cast<PProgram>(); }

  inline void replaceBy (PProgram node) { Node::replaceBy (node); }

protected:
  inline PProgram (_GenericNode *obj) : Node(obj) { }

private:
  void replaceBy (Node node);
};
class PEvent : public Node {
public:
  inline PEvent () : Node () { }

  static const _TypeInfo type_info;

  inline PEvent clone () const { return Node::clone().unsafe_cast<PEvent>(); }

  inline void replaceBy (PEvent node) { Node::replaceBy (node); }

protected:
  inline PEvent (_GenericNode *obj) : Node(obj) { }

private:
  void replaceBy (Node node);
};
class PProcedure : public Node {
public:
  inline PProcedure () : Node () { }

  static const _TypeInfo type_info;

  inline PProcedure clone () const { return Node::clone().unsafe_cast<PProcedure>(); }

  inline void replaceBy (PProcedure node) { Node::replaceBy (node); }

protected:
  inline PProcedure (_GenericNode *obj) : Node(obj) { }

private:
  void replaceBy (Node node);
};
class PLocal : public Node {
public:
  inline PLocal () : Node () { }

  static const _TypeInfo type_info;

  inline PLocal clone () const { return Node::clone().unsafe_cast<PLocal>(); }

  inline void replaceBy (PLocal node) { Node::replaceBy (node); }

protected:
  inline PLocal (_GenericNode *obj) : Node(obj) { }

private:
  void replaceBy (Node node);
};
class PStatement : public Node {
public:
  inline PStatement () : Node () { }

  static const _TypeInfo type_info;

  inline PStatement clone () const { return Node::clone().unsafe_cast<PStatement>(); }

  inline void replaceBy (PStatement node) { Node::replaceBy (node); }

protected:
  inline PStatement (_GenericNode *obj) : Node(obj) { }

private:
  void replaceBy (Node node);
};
class PElseMarker : public Node {
public:
  inline PElseMarker () : Node () { }

  static const _TypeInfo type_info;

  inline PElseMarker clone () const { return Node::clone().unsafe_cast<PElseMarker>(); }

  inline void replaceBy (PElseMarker node) { Node::replaceBy (node); }

protected:
  inline PElseMarker (_GenericNode *obj) : Node(obj) { }

private:
  void replaceBy (Node node);
};
class PExpression : public Node {
public:
  inline PExpression () : Node () { }

  static const _TypeInfo type_info;

  inline PExpression clone () const { return Node::clone().unsafe_cast<PExpression>(); }

  inline void replaceBy (PExpression node) { Node::replaceBy (node); }

protected:
  inline PExpression (_GenericNode *obj) : Node(obj) { }

private:
  void replaceBy (Node node);
};
class PBinop : public Node {
public:
  inline PBinop () : Node () { }

  static const _TypeInfo type_info;

  inline PBinop clone () const { return Node::clone().unsafe_cast<PBinop>(); }

  inline void replaceBy (PBinop node) { Node::replaceBy (node); }

protected:
  inline PBinop (_GenericNode *obj) : Node(obj) { }

private:
  void replaceBy (Node node);
};

class AProgram : public PProgram {
protected:
  inline AProgram (_GenericNode *obj) : PProgram (obj) { }

public:
  inline AProgram () : PProgram() { }

  static inline AProgram make () { return initProd (&type_info); }

  static inline AProgram make (
      List<PEvent>& _event_,
      List<PProcedure>& _procedure_
  )
  {
    void *args[] = {
        &getListGuts(_event_),
        &getListGuts(_procedure_)
    };
    return initProd (&type_info, args);
  }

  static const _TypeInfo type_info;

  inline AProgram clone () const { return Node::clone().unsafe_cast<AProgram>(); }

  inline void replaceBy (AProgram node) { Node::replaceBy (node); }

  inline List<PEvent>& getEvent () { return reinterpret_cast<List<PEvent>& >(getChildList(0)); }
  inline List<PProcedure>& getProcedure () { return reinterpret_cast<List<PProcedure>& >(getChildList(1)); }

private:
  void replaceBy (PProgram node);
};
class AWaitEvent : public PEvent {
protected:
  inline AWaitEvent (_GenericNode *obj) : PEvent (obj) { }

public:
  inline AWaitEvent () : PEvent() { }

  static inline AWaitEvent make () { return initProd (&type_info); }

  static inline AWaitEvent make (
      PExpression _expression_
  )
  {
    void *args[] = {
        &_expression_
    };
    return initProd (&type_info, args);
  }

  static const _TypeInfo type_info;

  inline AWaitEvent clone () const { return Node::clone().unsafe_cast<AWaitEvent>(); }

  inline void replaceBy (AWaitEvent node) { Node::replaceBy (node); }

  inline PExpression getExpression () { return getChildNode(0).unsafe_cast<PExpression>(); }
  inline void setExpression (PExpression _expression_) { setChildNode (0, _expression_); }

private:
  void replaceBy (PEvent node);
};
class AColorEvent : public PEvent {
protected:
  inline AColorEvent (_GenericNode *obj) : PEvent (obj) { }

public:
  inline AColorEvent () : PEvent() { }

  static inline AColorEvent make () { return initProd (&type_info); }

  static inline AColorEvent make (
      TColor _color_
  )
  {
    void *args[] = {
        &_color_
    };
    return initProd (&type_info, args);
  }

  static const _TypeInfo type_info;

  inline AColorEvent clone () const { return Node::clone().unsafe_cast<AColorEvent>(); }

  inline void replaceBy (AColorEvent node) { Node::replaceBy (node); }

  inline TColor getColor () { return getChildNode(0).unsafe_cast<TColor>(); }
  inline void setColor (TColor _color_) { setChildNode (0, _color_); }

private:
  void replaceBy (PEvent node);
};
class AProcedure : public PProcedure {
protected:
  inline AProcedure (_GenericNode *obj) : PProcedure (obj) { }

public:
  inline AProcedure () : PProcedure() { }

  static inline AProcedure make () { return initProd (&type_info); }

  static inline AProcedure make (
      TIdentifier _name_,
      List<PLocal>& _params_,
      List<PStatement>& _body_
  )
  {
    void *args[] = {
        &_name_,
        &getListGuts(_params_),
        &getListGuts(_body_)
    };
    return initProd (&type_info, args);
  }

  static const _TypeInfo type_info;

  inline AProcedure clone () const { return Node::clone().unsafe_cast<AProcedure>(); }

  inline void replaceBy (AProcedure node) { Node::replaceBy (node); }

  inline TIdentifier getName () { return getChildNode(0).unsafe_cast<TIdentifier>(); }
  inline void setName (TIdentifier _name_) { setChildNode (0, _name_); }
  inline List<PLocal>& getParams () { return reinterpret_cast<List<PLocal>& >(getChildList(1)); }
  inline List<PStatement>& getBody () { return reinterpret_cast<List<PStatement>& >(getChildList(2)); }

private:
  void replaceBy (PProcedure node);
};
class ALocal : public PLocal {
protected:
  inline ALocal (_GenericNode *obj) : PLocal (obj) { }

public:
  inline ALocal () : PLocal() { }

  static inline ALocal make () { return initProd (&type_info); }

  static inline ALocal make (
      TIdentifier _name_
  )
  {
    void *args[] = {
        &_name_
    };
    return initProd (&type_info, args);
  }

  static const _TypeInfo type_info;

  inline ALocal clone () const { return Node::clone().unsafe_cast<ALocal>(); }

  inline void replaceBy (ALocal node) { Node::replaceBy (node); }

  inline TIdentifier getName () { return getChildNode(0).unsafe_cast<TIdentifier>(); }
  inline void setName (TIdentifier _name_) { setChildNode (0, _name_); }

private:
  void replaceBy (PLocal node);
};
class ADrawStatement : public PStatement {
protected:
  inline ADrawStatement (_GenericNode *obj) : PStatement (obj) { }

public:
  inline ADrawStatement () : PStatement() { }

  static inline ADrawStatement make () { return initProd (&type_info); }

  static inline ADrawStatement make (
      TDraw _token_
  )
  {
    void *args[] = {
        &_token_
    };
    return initProd (&type_info, args);
  }

  static const _TypeInfo type_info;

  inline ADrawStatement clone () const { return Node::clone().unsafe_cast<ADrawStatement>(); }

  inline void replaceBy (ADrawStatement node) { Node::replaceBy (node); }

  inline TDraw getToken () { return getChildNode(0).unsafe_cast<TDraw>(); }
  inline void setToken (TDraw _token_) { setChildNode (0, _token_); }

private:
  void replaceBy (PStatement node);
};
class AForkStatement : public PStatement {
protected:
  inline AForkStatement (_GenericNode *obj) : PStatement (obj) { }

public:
  inline AForkStatement () : PStatement() { }

  static inline AForkStatement make () { return initProd (&type_info); }

  static inline AForkStatement make (
      TFork _token_,
      PExpression _proc_,
      List<PExpression>& _args_
  )
  {
    void *args[] = {
        &_token_,
        &_proc_,
        &getListGuts(_args_)
    };
    return initProd (&type_info, args);
  }

  static const _TypeInfo type_info;

  inline AForkStatement clone () const { return Node::clone().unsafe_cast<AForkStatement>(); }

  inline void replaceBy (AForkStatement node) { Node::replaceBy (node); }

  inline TFork getToken () { return getChildNode(0).unsafe_cast<TFork>(); }
  inline void setToken (TFork _token_) { setChildNode (0, _token_); }
  inline PExpression getProc () { return getChildNode(1).unsafe_cast<PExpression>(); }
  inline void setProc (PExpression _proc_) { setChildNode (1, _proc_); }
  inline List<PExpression>& getArgs () { return reinterpret_cast<List<PExpression>& >(getChildList(2)); }

private:
  void replaceBy (PStatement node);
};
class AMoveStatement : public PStatement {
protected:
  inline AMoveStatement (_GenericNode *obj) : PStatement (obj) { }

public:
  inline AMoveStatement () : PStatement() { }

  static inline AMoveStatement make () { return initProd (&type_info); }

  static inline AMoveStatement make (
      TMove _token_,
      PExpression _expression_
  )
  {
    void *args[] = {
        &_token_,
        &_expression_
    };
    return initProd (&type_info, args);
  }

  static const _TypeInfo type_info;

  inline AMoveStatement clone () const { return Node::clone().unsafe_cast<AMoveStatement>(); }

  inline void replaceBy (AMoveStatement node) { Node::replaceBy (node); }

  inline TMove getToken () { return getChildNode(0).unsafe_cast<TMove>(); }
  inline void setToken (TMove _token_) { setChildNode (0, _token_); }
  inline PExpression getExpression () { return getChildNode(1).unsafe_cast<PExpression>(); }
  inline void setExpression (PExpression _expression_) { setChildNode (1, _expression_); }

private:
  void replaceBy (PStatement node);
};
class ASizeStatement : public PStatement {
protected:
  inline ASizeStatement (_GenericNode *obj) : PStatement (obj) { }

public:
  inline ASizeStatement () : PStatement() { }

  static inline ASizeStatement make () { return initProd (&type_info); }

  static inline ASizeStatement make (
      TSize _token_,
      PExpression _expression_
  )
  {
    void *args[] = {
        &_token_,
        &_expression_
    };
    return initProd (&type_info, args);
  }

  static const _TypeInfo type_info;

  inline ASizeStatement clone () const { return Node::clone().unsafe_cast<ASizeStatement>(); }

  inline void replaceBy (ASizeStatement node) { Node::replaceBy (node); }

  inline TSize getToken () { return getChildNode(0).unsafe_cast<TSize>(); }
  inline void setToken (TSize _token_) { setChildNode (0, _token_); }
  inline PExpression getExpression () { return getChildNode(1).unsafe_cast<PExpression>(); }
  inline void setExpression (PExpression _expression_) { setChildNode (1, _expression_); }

private:
  void replaceBy (PStatement node);
};
class ATempStatement : public PStatement {
protected:
  inline ATempStatement (_GenericNode *obj) : PStatement (obj) { }

public:
  inline ATempStatement () : PStatement() { }

  static inline ATempStatement make () { return initProd (&type_info); }

  static inline ATempStatement make (
      PLocal _var_,
      PExpression _expression_
  )
  {
    void *args[] = {
        &_var_,
        &_expression_
    };
    return initProd (&type_info, args);
  }

  static const _TypeInfo type_info;

  inline ATempStatement clone () const { return Node::clone().unsafe_cast<ATempStatement>(); }

  inline void replaceBy (ATempStatement node) { Node::replaceBy (node); }

  inline PLocal getVar () { return getChildNode(0).unsafe_cast<PLocal>(); }
  inline void setVar (PLocal _var_) { setChildNode (0, _var_); }
  inline PExpression getExpression () { return getChildNode(1).unsafe_cast<PExpression>(); }
  inline void setExpression (PExpression _expression_) { setChildNode (1, _expression_); }

private:
  void replaceBy (PStatement node);
};
class ATintStatement : public PStatement {
protected:
  inline ATintStatement (_GenericNode *obj) : PStatement (obj) { }

public:
  inline ATintStatement () : PStatement() { }

  static inline ATintStatement make () { return initProd (&type_info); }

  static inline ATintStatement make (
      TTint _token_,
      PExpression _expression_
  )
  {
    void *args[] = {
        &_token_,
        &_expression_
    };
    return initProd (&type_info, args);
  }

  static const _TypeInfo type_info;

  inline ATintStatement clone () const { return Node::clone().unsafe_cast<ATintStatement>(); }

  inline void replaceBy (ATintStatement node) { Node::replaceBy (node); }

  inline TTint getToken () { return getChildNode(0).unsafe_cast<TTint>(); }
  inline void setToken (TTint _token_) { setChildNode (0, _token_); }
  inline PExpression getExpression () { return getChildNode(1).unsafe_cast<PExpression>(); }
  inline void setExpression (PExpression _expression_) { setChildNode (1, _expression_); }

private:
  void replaceBy (PStatement node);
};
class ATurnStatement : public PStatement {
protected:
  inline ATurnStatement (_GenericNode *obj) : PStatement (obj) { }

public:
  inline ATurnStatement () : PStatement() { }

  static inline ATurnStatement make () { return initProd (&type_info); }

  static inline ATurnStatement make (
      TTurn _token_,
      PExpression _expression_
  )
  {
    void *args[] = {
        &_token_,
        &_expression_
    };
    return initProd (&type_info, args);
  }

  static const _TypeInfo type_info;

  inline ATurnStatement clone () const { return Node::clone().unsafe_cast<ATurnStatement>(); }

  inline void replaceBy (ATurnStatement node) { Node::replaceBy (node); }

  inline TTurn getToken () { return getChildNode(0).unsafe_cast<TTurn>(); }
  inline void setToken (TTurn _token_) { setChildNode (0, _token_); }
  inline PExpression getExpression () { return getChildNode(1).unsafe_cast<PExpression>(); }
  inline void setExpression (PExpression _expression_) { setChildNode (1, _expression_); }

private:
  void replaceBy (PStatement node);
};
class AFaceStatement : public PStatement {
protected:
  inline AFaceStatement (_GenericNode *obj) : PStatement (obj) { }

public:
  inline AFaceStatement () : PStatement() { }

  static inline AFaceStatement make () { return initProd (&type_info); }

  static inline AFaceStatement make (
      TFace _token_,
      PExpression _expression_
  )
  {
    void *args[] = {
        &_token_,
        &_expression_
    };
    return initProd (&type_info, args);
  }

  static const _TypeInfo type_info;

  inline AFaceStatement clone () const { return Node::clone().unsafe_cast<AFaceStatement>(); }

  inline void replaceBy (AFaceStatement node) { Node::replaceBy (node); }

  inline TFace getToken () { return getChildNode(0).unsafe_cast<TFace>(); }
  inline void setToken (TFace _token_) { setChildNode (0, _token_); }
  inline PExpression getExpression () { return getChildNode(1).unsafe_cast<PExpression>(); }
  inline void setExpression (PExpression _expression_) { setChildNode (1, _expression_); }

private:
  void replaceBy (PStatement node);
};
class AWaitStatement : public PStatement {
protected:
  inline AWaitStatement (_GenericNode *obj) : PStatement (obj) { }

public:
  inline AWaitStatement () : PStatement() { }

  static inline AWaitStatement make () { return initProd (&type_info); }

  static inline AWaitStatement make (
      TWait _token_,
      PExpression _expression_
  )
  {
    void *args[] = {
        &_token_,
        &_expression_
    };
    return initProd (&type_info, args);
  }

  static const _TypeInfo type_info;

  inline AWaitStatement clone () const { return Node::clone().unsafe_cast<AWaitStatement>(); }

  inline void replaceBy (AWaitStatement node) { Node::replaceBy (node); }

  inline TWait getToken () { return getChildNode(0).unsafe_cast<TWait>(); }
  inline void setToken (TWait _token_) { setChildNode (0, _token_); }
  inline PExpression getExpression () { return getChildNode(1).unsafe_cast<PExpression>(); }
  inline void setExpression (PExpression _expression_) { setChildNode (1, _expression_); }

private:
  void replaceBy (PStatement node);
};
class ASeedStatement : public PStatement {
protected:
  inline ASeedStatement (_GenericNode *obj) : PStatement (obj) { }

public:
  inline ASeedStatement () : PStatement() { }

  static inline ASeedStatement make () { return initProd (&type_info); }

  static inline ASeedStatement make (
      TSeed _token_,
      PExpression _expression_
  )
  {
    void *args[] = {
        &_token_,
        &_expression_
    };
    return initProd (&type_info, args);
  }

  static const _TypeInfo type_info;

  inline ASeedStatement clone () const { return Node::clone().unsafe_cast<ASeedStatement>(); }

  inline void replaceBy (ASeedStatement node) { Node::replaceBy (node); }

  inline TSeed getToken () { return getChildNode(0).unsafe_cast<TSeed>(); }
  inline void setToken (TSeed _token_) { setChildNode (0, _token_); }
  inline PExpression getExpression () { return getChildNode(1).unsafe_cast<PExpression>(); }
  inline void setExpression (PExpression _expression_) { setChildNode (1, _expression_); }

private:
  void replaceBy (PStatement node);
};
class AWhenStatement : public PStatement {
protected:
  inline AWhenStatement (_GenericNode *obj) : PStatement (obj) { }

public:
  inline AWhenStatement () : PStatement() { }

  static inline AWhenStatement make () { return initProd (&type_info); }

  static inline AWhenStatement make (
      TWhen _token_,
      PExpression _cond_,
      List<PStatement>& _when_,
      PElseMarker _between_,
      List<PStatement>& _else_
  )
  {
    void *args[] = {
        &_token_,
        &_cond_,
        &getListGuts(_when_),
        &_between_,
        &getListGuts(_else_)
    };
    return initProd (&type_info, args);
  }

  static const _TypeInfo type_info;

  inline AWhenStatement clone () const { return Node::clone().unsafe_cast<AWhenStatement>(); }

  inline void replaceBy (AWhenStatement node) { Node::replaceBy (node); }

  inline TWhen getToken () { return getChildNode(0).unsafe_cast<TWhen>(); }
  inline void setToken (TWhen _token_) { setChildNode (0, _token_); }
  inline PExpression getCond () { return getChildNode(1).unsafe_cast<PExpression>(); }
  inline void setCond (PExpression _cond_) { setChildNode (1, _cond_); }
  inline List<PStatement>& getWhen () { return reinterpret_cast<List<PStatement>& >(getChildList(2)); }
  inline PElseMarker getBetween () { return getChildNode(3).unsafe_cast<PElseMarker>(); }
  inline void setBetween (PElseMarker _between_) { setChildNode (3, _between_); }
  inline List<PStatement>& getElse () { return reinterpret_cast<List<PStatement>& >(getChildList(4)); }

private:
  void replaceBy (PStatement node);
};
class AElseMarker : public PElseMarker {
protected:
  inline AElseMarker (_GenericNode *obj) : PElseMarker (obj) { }

public:
  inline AElseMarker () : PElseMarker() { }


  static inline AElseMarker make (
  )
  {
    void *args[] = {
    };
    return initProd (&type_info, args);
  }

  static const _TypeInfo type_info;

  inline AElseMarker clone () const { return Node::clone().unsafe_cast<AElseMarker>(); }

  inline void replaceBy (AElseMarker node) { Node::replaceBy (node); }


private:
  void replaceBy (PElseMarker node);
};
class ANumberExpression : public PExpression {
protected:
  inline ANumberExpression (_GenericNode *obj) : PExpression (obj) { }

public:
  inline ANumberExpression () : PExpression() { }

  static inline ANumberExpression make () { return initProd (&type_info); }

  static inline ANumberExpression make (
      TNumber _number_
  )
  {
    void *args[] = {
        &_number_
    };
    return initProd (&type_info, args);
  }

  static const _TypeInfo type_info;

  inline ANumberExpression clone () const { return Node::clone().unsafe_cast<ANumberExpression>(); }

  inline void replaceBy (ANumberExpression node) { Node::replaceBy (node); }

  inline TNumber getNumber () { return getChildNode(0).unsafe_cast<TNumber>(); }
  inline void setNumber (TNumber _number_) { setChildNode (0, _number_); }

private:
  void replaceBy (PExpression node);
};
class AVarExpression : public PExpression {
protected:
  inline AVarExpression (_GenericNode *obj) : PExpression (obj) { }

public:
  inline AVarExpression () : PExpression() { }

  static inline AVarExpression make () { return initProd (&type_info); }

  static inline AVarExpression make (
      TIdentifier _name_
  )
  {
    void *args[] = {
        &_name_
    };
    return initProd (&type_info, args);
  }

  static const _TypeInfo type_info;

  inline AVarExpression clone () const { return Node::clone().unsafe_cast<AVarExpression>(); }

  inline void replaceBy (AVarExpression node) { Node::replaceBy (node); }

  inline TIdentifier getName () { return getChildNode(0).unsafe_cast<TIdentifier>(); }
  inline void setName (TIdentifier _name_) { setChildNode (0, _name_); }

private:
  void replaceBy (PExpression node);
};
class ABinaryExpression : public PExpression {
protected:
  inline ABinaryExpression (_GenericNode *obj) : PExpression (obj) { }

public:
  inline ABinaryExpression () : PExpression() { }

  static inline ABinaryExpression make () { return initProd (&type_info); }

  static inline ABinaryExpression make (
      PBinop _op_,
      PExpression _left_,
      PExpression _right_
  )
  {
    void *args[] = {
        &_op_,
        &_left_,
        &_right_
    };
    return initProd (&type_info, args);
  }

  static const _TypeInfo type_info;

  inline ABinaryExpression clone () const { return Node::clone().unsafe_cast<ABinaryExpression>(); }

  inline void replaceBy (ABinaryExpression node) { Node::replaceBy (node); }

  inline PBinop getOp () { return getChildNode(0).unsafe_cast<PBinop>(); }
  inline void setOp (PBinop _op_) { setChildNode (0, _op_); }
  inline PExpression getLeft () { return getChildNode(1).unsafe_cast<PExpression>(); }
  inline void setLeft (PExpression _left_) { setChildNode (1, _left_); }
  inline PExpression getRight () { return getChildNode(2).unsafe_cast<PExpression>(); }
  inline void setRight (PExpression _right_) { setChildNode (2, _right_); }

private:
  void replaceBy (PExpression node);
};
class ANegExpression : public PExpression {
protected:
  inline ANegExpression (_GenericNode *obj) : PExpression (obj) { }

public:
  inline ANegExpression () : PExpression() { }

  static inline ANegExpression make () { return initProd (&type_info); }

  static inline ANegExpression make (
      TNeg _token_,
      PExpression _expression_
  )
  {
    void *args[] = {
        &_token_,
        &_expression_
    };
    return initProd (&type_info, args);
  }

  static const _TypeInfo type_info;

  inline ANegExpression clone () const { return Node::clone().unsafe_cast<ANegExpression>(); }

  inline void replaceBy (ANegExpression node) { Node::replaceBy (node); }

  inline TNeg getToken () { return getChildNode(0).unsafe_cast<TNeg>(); }
  inline void setToken (TNeg _token_) { setChildNode (0, _token_); }
  inline PExpression getExpression () { return getChildNode(1).unsafe_cast<PExpression>(); }
  inline void setExpression (PExpression _expression_) { setChildNode (1, _expression_); }

private:
  void replaceBy (PExpression node);
};
class ASineExpression : public PExpression {
protected:
  inline ASineExpression (_GenericNode *obj) : PExpression (obj) { }

public:
  inline ASineExpression () : PExpression() { }

  static inline ASineExpression make () { return initProd (&type_info); }

  static inline ASineExpression make (
      TSine _token_,
      PExpression _expression_
  )
  {
    void *args[] = {
        &_token_,
        &_expression_
    };
    return initProd (&type_info, args);
  }

  static const _TypeInfo type_info;

  inline ASineExpression clone () const { return Node::clone().unsafe_cast<ASineExpression>(); }

  inline void replaceBy (ASineExpression node) { Node::replaceBy (node); }

  inline TSine getToken () { return getChildNode(0).unsafe_cast<TSine>(); }
  inline void setToken (TSine _token_) { setChildNode (0, _token_); }
  inline PExpression getExpression () { return getChildNode(1).unsafe_cast<PExpression>(); }
  inline void setExpression (PExpression _expression_) { setChildNode (1, _expression_); }

private:
  void replaceBy (PExpression node);
};
class ARandExpression : public PExpression {
protected:
  inline ARandExpression (_GenericNode *obj) : PExpression (obj) { }

public:
  inline ARandExpression () : PExpression() { }

  static inline ARandExpression make () { return initProd (&type_info); }

  static inline ARandExpression make (
      TRand _token_
  )
  {
    void *args[] = {
        &_token_
    };
    return initProd (&type_info, args);
  }

  static const _TypeInfo type_info;

  inline ARandExpression clone () const { return Node::clone().unsafe_cast<ARandExpression>(); }

  inline void replaceBy (ARandExpression node) { Node::replaceBy (node); }

  inline TRand getToken () { return getChildNode(0).unsafe_cast<TRand>(); }
  inline void setToken (TRand _token_) { setChildNode (0, _token_); }

private:
  void replaceBy (PExpression node);
};
class APlusBinop : public PBinop {
protected:
  inline APlusBinop (_GenericNode *obj) : PBinop (obj) { }

public:
  inline APlusBinop () : PBinop() { }

  static inline APlusBinop make () { return initProd (&type_info); }

  static inline APlusBinop make (
      TPlus _plus_
  )
  {
    void *args[] = {
        &_plus_
    };
    return initProd (&type_info, args);
  }

  static const _TypeInfo type_info;

  inline APlusBinop clone () const { return Node::clone().unsafe_cast<APlusBinop>(); }

  inline void replaceBy (APlusBinop node) { Node::replaceBy (node); }

  inline TPlus getPlus () { return getChildNode(0).unsafe_cast<TPlus>(); }
  inline void setPlus (TPlus _plus_) { setChildNode (0, _plus_); }

private:
  void replaceBy (PBinop node);
};
class AMinusBinop : public PBinop {
protected:
  inline AMinusBinop (_GenericNode *obj) : PBinop (obj) { }

public:
  inline AMinusBinop () : PBinop() { }

  static inline AMinusBinop make () { return initProd (&type_info); }

  static inline AMinusBinop make (
      TMinus _minus_
  )
  {
    void *args[] = {
        &_minus_
    };
    return initProd (&type_info, args);
  }

  static const _TypeInfo type_info;

  inline AMinusBinop clone () const { return Node::clone().unsafe_cast<AMinusBinop>(); }

  inline void replaceBy (AMinusBinop node) { Node::replaceBy (node); }

  inline TMinus getMinus () { return getChildNode(0).unsafe_cast<TMinus>(); }
  inline void setMinus (TMinus _minus_) { setChildNode (0, _minus_); }

private:
  void replaceBy (PBinop node);
};
class AMultiplyBinop : public PBinop {
protected:
  inline AMultiplyBinop (_GenericNode *obj) : PBinop (obj) { }

public:
  inline AMultiplyBinop () : PBinop() { }

  static inline AMultiplyBinop make () { return initProd (&type_info); }

  static inline AMultiplyBinop make (
      TMul _mul_
  )
  {
    void *args[] = {
        &_mul_
    };
    return initProd (&type_info, args);
  }

  static const _TypeInfo type_info;

  inline AMultiplyBinop clone () const { return Node::clone().unsafe_cast<AMultiplyBinop>(); }

  inline void replaceBy (AMultiplyBinop node) { Node::replaceBy (node); }

  inline TMul getMul () { return getChildNode(0).unsafe_cast<TMul>(); }
  inline void setMul (TMul _mul_) { setChildNode (0, _mul_); }

private:
  void replaceBy (PBinop node);
};
class ADivideBinop : public PBinop {
protected:
  inline ADivideBinop (_GenericNode *obj) : PBinop (obj) { }

public:
  inline ADivideBinop () : PBinop() { }

  static inline ADivideBinop make () { return initProd (&type_info); }

  static inline ADivideBinop make (
      TDiv _div_
  )
  {
    void *args[] = {
        &_div_
    };
    return initProd (&type_info, args);
  }

  static const _TypeInfo type_info;

  inline ADivideBinop clone () const { return Node::clone().unsafe_cast<ADivideBinop>(); }

  inline void replaceBy (ADivideBinop node) { Node::replaceBy (node); }

  inline TDiv getDiv () { return getChildNode(0).unsafe_cast<TDiv>(); }
  inline void setDiv (TDiv _div_) { setChildNode (0, _div_); }

private:
  void replaceBy (PBinop node);
};
class AEqBinop : public PBinop {
protected:
  inline AEqBinop (_GenericNode *obj) : PBinop (obj) { }

public:
  inline AEqBinop () : PBinop() { }

  static inline AEqBinop make () { return initProd (&type_info); }

  static inline AEqBinop make (
      TEq _eq_
  )
  {
    void *args[] = {
        &_eq_
    };
    return initProd (&type_info, args);
  }

  static const _TypeInfo type_info;

  inline AEqBinop clone () const { return Node::clone().unsafe_cast<AEqBinop>(); }

  inline void replaceBy (AEqBinop node) { Node::replaceBy (node); }

  inline TEq getEq () { return getChildNode(0).unsafe_cast<TEq>(); }
  inline void setEq (TEq _eq_) { setChildNode (0, _eq_); }

private:
  void replaceBy (PBinop node);
};
class ANeBinop : public PBinop {
protected:
  inline ANeBinop (_GenericNode *obj) : PBinop (obj) { }

public:
  inline ANeBinop () : PBinop() { }

  static inline ANeBinop make () { return initProd (&type_info); }

  static inline ANeBinop make (
      TNe _ne_
  )
  {
    void *args[] = {
        &_ne_
    };
    return initProd (&type_info, args);
  }

  static const _TypeInfo type_info;

  inline ANeBinop clone () const { return Node::clone().unsafe_cast<ANeBinop>(); }

  inline void replaceBy (ANeBinop node) { Node::replaceBy (node); }

  inline TNe getNe () { return getChildNode(0).unsafe_cast<TNe>(); }
  inline void setNe (TNe _ne_) { setChildNode (0, _ne_); }

private:
  void replaceBy (PBinop node);
};
class ALtBinop : public PBinop {
protected:
  inline ALtBinop (_GenericNode *obj) : PBinop (obj) { }

public:
  inline ALtBinop () : PBinop() { }

  static inline ALtBinop make () { return initProd (&type_info); }

  static inline ALtBinop make (
      TLt _lt_
  )
  {
    void *args[] = {
        &_lt_
    };
    return initProd (&type_info, args);
  }

  static const _TypeInfo type_info;

  inline ALtBinop clone () const { return Node::clone().unsafe_cast<ALtBinop>(); }

  inline void replaceBy (ALtBinop node) { Node::replaceBy (node); }

  inline TLt getLt () { return getChildNode(0).unsafe_cast<TLt>(); }
  inline void setLt (TLt _lt_) { setChildNode (0, _lt_); }

private:
  void replaceBy (PBinop node);
};
class ALeBinop : public PBinop {
protected:
  inline ALeBinop (_GenericNode *obj) : PBinop (obj) { }

public:
  inline ALeBinop () : PBinop() { }

  static inline ALeBinop make () { return initProd (&type_info); }

  static inline ALeBinop make (
      TLe _le_
  )
  {
    void *args[] = {
        &_le_
    };
    return initProd (&type_info, args);
  }

  static const _TypeInfo type_info;

  inline ALeBinop clone () const { return Node::clone().unsafe_cast<ALeBinop>(); }

  inline void replaceBy (ALeBinop node) { Node::replaceBy (node); }

  inline TLe getLe () { return getChildNode(0).unsafe_cast<TLe>(); }
  inline void setLe (TLe _le_) { setChildNode (0, _le_); }

private:
  void replaceBy (PBinop node);
};
class AGtBinop : public PBinop {
protected:
  inline AGtBinop (_GenericNode *obj) : PBinop (obj) { }

public:
  inline AGtBinop () : PBinop() { }

  static inline AGtBinop make () { return initProd (&type_info); }

  static inline AGtBinop make (
      TGt _gt_
  )
  {
    void *args[] = {
        &_gt_
    };
    return initProd (&type_info, args);
  }

  static const _TypeInfo type_info;

  inline AGtBinop clone () const { return Node::clone().unsafe_cast<AGtBinop>(); }

  inline void replaceBy (AGtBinop node) { Node::replaceBy (node); }

  inline TGt getGt () { return getChildNode(0).unsafe_cast<TGt>(); }
  inline void setGt (TGt _gt_) { setChildNode (0, _gt_); }

private:
  void replaceBy (PBinop node);
};
class AGeBinop : public PBinop {
protected:
  inline AGeBinop (_GenericNode *obj) : PBinop (obj) { }

public:
  inline AGeBinop () : PBinop() { }

  static inline AGeBinop make () { return initProd (&type_info); }

  static inline AGeBinop make (
      TGe _ge_
  )
  {
    void *args[] = {
        &_ge_
    };
    return initProd (&type_info, args);
  }

  static const _TypeInfo type_info;

  inline AGeBinop clone () const { return Node::clone().unsafe_cast<AGeBinop>(); }

  inline void replaceBy (AGeBinop node) { Node::replaceBy (node); }

  inline TGe getGe () { return getChildNode(0).unsafe_cast<TGe>(); }
  inline void setGe (TGe _ge_) { setChildNode (0, _ge_); }

private:
  void replaceBy (PBinop node);
};
class AAndBinop : public PBinop {
protected:
  inline AAndBinop (_GenericNode *obj) : PBinop (obj) { }

public:
  inline AAndBinop () : PBinop() { }

  static inline AAndBinop make () { return initProd (&type_info); }

  static inline AAndBinop make (
      TAnd _and_
  )
  {
    void *args[] = {
        &_and_
    };
    return initProd (&type_info, args);
  }

  static const _TypeInfo type_info;

  inline AAndBinop clone () const { return Node::clone().unsafe_cast<AAndBinop>(); }

  inline void replaceBy (AAndBinop node) { Node::replaceBy (node); }

  inline TAnd getAnd () { return getChildNode(0).unsafe_cast<TAnd>(); }
  inline void setAnd (TAnd _and_) { setChildNode (0, _and_); }

private:
  void replaceBy (PBinop node);
};
class AOrBinop : public PBinop {
protected:
  inline AOrBinop (_GenericNode *obj) : PBinop (obj) { }

public:
  inline AOrBinop () : PBinop() { }

  static inline AOrBinop make () { return initProd (&type_info); }

  static inline AOrBinop make (
      TOr _or_
  )
  {
    void *args[] = {
        &_or_
    };
    return initProd (&type_info, args);
  }

  static const _TypeInfo type_info;

  inline AOrBinop clone () const { return Node::clone().unsafe_cast<AOrBinop>(); }

  inline void replaceBy (AOrBinop node) { Node::replaceBy (node); }

  inline TOr getOr () { return getChildNode(0).unsafe_cast<TOr>(); }
  inline void setOr (TOr _or_) { setChildNode (0, _or_); }

private:
  void replaceBy (PBinop node);
};

class Start : public Node {
protected:
  Start (_GenericNode *obj) : Node(obj) { }

public:
  inline Start () : Node () { };

  static const _TypeInfo type_info;

  static inline Start make () { return initProd(&type_info); }
  static inline Start make (PProgram start, TEOF eof)
  {
    void *args[] = { &start, &eof };
    return initProd (&type_info, args);
  }

  inline PProgram getPProgram () { return getChildNode (0).unsafe_cast<PProgram>(); }
  inline void setPProgram(PProgram node) { setChildNode(0, node); }
  inline TEOF getTEOF() { return getChildNode(1).unsafe_cast<TEOF>(); }
  inline void setTEOF (TEOF node) { setChildNode(1, node); }

  inline Start clone () const { return Node::clone().unsafe_cast<Start>(); }

  inline void replaceBy (Start node) { Node::replaceBy (node); }

private:
  void replaceBy (Node node);
};

} // namespace rose {

#endif // !__rose__prod_hh__
